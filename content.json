{"pages":[],"posts":[{"title":"Zipkin原理学习 -- Druid 追踪多种数据库 SQL 执行","text":"在上一篇博客 《Zipkin原理学习–日志追踪 MySQL 执行语句》 中我们已经了解学习到 Zipkin 官方提供的针对 MySQL 数据库 sql 语句执行的追踪拦截器，现在我们基于数据库连接池 Druid 的 Filter 机制 写一个能支持多种数据库（mysql，pg、oracle 等）日志追踪拦截器。 Druid 过滤器 Filter DruidDataSource支持通过Filter-Chain模式进行扩展，类似Serlvet的Filter，扩展十分方便，你可以拦截任何JDBC的方法。 有两种配置Filter的方式，一种是配置filters属性，一种是配置proxyFilters属性。filters和proxyFilters的配置是组合关系，而不是替换关系。 配置filters属性配置filters属性比较简单，filters的类型是字符串，多个filter使用逗号隔开。例如： 1234567&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:derby:memory:spring-test;create=true&quot; /&gt; &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;property name=&quot;filters&quot; value=&quot;stat,log4j&quot; /&gt; &lt;/bean&gt; filters属性的配置使用别名或者全类名，stat是com.alibaba.druid.filter.stat.StatFilter的别名。在这里 内置Filter的别名 查看内置Filter的别名。 配置proxyFilters属性proxyFilters的类型是List，使用proxyFilters配置，可以有更多的配置选项。 1234567891011121314&lt;bean id=&quot;stat-filter&quot; class=&quot;com.alibaba.druid.filter.stat.StatFilter&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:derby:memory:spring-test;create=true&quot; /&gt; &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;property name=&quot;proxyFilters&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;stat-filter&quot; /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; Zipkin 日志追踪过滤器 TracingStatementFilter TracingStatementFilter 继承抽象类 FilterEventAdapter 实现以下接口： 1234567891011121314151617181920212223242526protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) { } protected void statementExecuteUpdateAfter(StatementProxy statement, String sql, int updateCount) { } protected void statementExecuteQueryBefore(StatementProxy statement, String sql) { } protected void statementExecuteQueryAfter(StatementProxy statement, String sql, ResultSetProxy resultSet) { } protected void statementExecuteBefore(StatementProxy statement, String sql) { } protected void statementExecuteAfter(StatementProxy statement, String sql, boolean result) { } protected void statementExecuteBatchBefore(StatementProxy statement) { } protected void statementExecuteBatchAfter(StatementProxy statement, int[] result) { } protected void statement_executeErrorAfter(StatementProxy statement, String sql, Throwable error) { } 实现以上接口，在执行SQL语句之前、之后或抛出异常时都会执行上面接口方法，这样就可以追踪 SQL 语句的执行过程了。完整 Zipkin 日志追踪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216public class TracingStatementFilter extends FilterEventAdapter { private String zipkinServiceName; public TracingStatementFilter(String zipkinServiceName){ this.zipkinServiceName = zipkinServiceName; } public TracingStatementFilter(){ } @Override protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) { super.statementExecuteUpdateBefore(statement,sql); try { Before(statement,sql); }catch (Exception e){ } } @Override protected void statementExecuteUpdateAfter(StatementProxy statement, String sql, int updateCount) { super.statementExecuteUpdateAfter(statement,sql,updateCount); try { After(statement,sql); }catch (Exception e){ } } @Override protected void statementExecuteQueryBefore(StatementProxy statement, String sql) { super.statementExecuteQueryBefore(statement,sql); try { Before(statement,sql); }catch (Exception e){ } } @Override protected void statementExecuteQueryAfter(StatementProxy statement, String sql, ResultSetProxy resultSet) { super.statementExecuteQueryAfter(statement,sql,resultSet); try { After(statement,sql); }catch (Exception e){ } } @Override protected void statementExecuteBefore(StatementProxy statement, String sql) { super.statementExecuteBefore(statement,sql); try { Before(statement,sql); }catch (Exception e){ } } @Override protected void statementExecuteAfter(StatementProxy statement, String sql, boolean result) { super.statementExecuteAfter(statement,sql,result); try { After(statement,sql); }catch (Exception e){ } } @Override protected void statementExecuteBatchBefore(StatementProxy statement) { super.statementExecuteBatchBefore(statement); try { Before(statement , null); }catch (Exception e){ } } @Override protected void statementExecuteBatchAfter(StatementProxy statement, int[] result) { super.statementExecuteBatchAfter(statement , result); try { After(statement , null); }catch (Exception e){ } } @Override protected void statement_executeErrorAfter(StatementProxy statement, String sql, Throwable error) { super.statement_executeErrorAfter(statement , sql , error); try { ErrorAfter(statement , sql , error); }catch (Exception e){ } } protected void Before(StatementProxy statement, String sql) { Span span = ThreadLocalSpan.CURRENT_TRACER.next(); if (span == null || span.isNoop()) { return; } if(sql == null){ sql = statement.getLastExecuteSql(); } // Allow span names of single-word statements like COMMIT int spaceIndex = sql.indexOf(&apos; &apos;); span.kind(Span.Kind.CLIENT).name(spaceIndex == -1 ? sql : sql.substring(0, spaceIndex)); span.tag(&quot;sql.query&quot;, sql); parseServerIpAndPort(statement,span); span.start(); } protected void After(StatementProxy statement, String sql) { Span span = ThreadLocalSpan.CURRENT_TRACER.remove(); if (span == null || span.isNoop()) { return; } span.finish(); return ; } protected void ErrorAfter(StatementProxy statement, String sql, Throwable error) { Span span = ThreadLocalSpan.CURRENT_TRACER.remove(); if (span == null || span.isNoop()) { return; } if (error instanceof SQLException) { span.tag(&quot;error&quot;, Integer.toString(((SQLException) error).getErrorCode())); } span.finish(); return ; } public void parseServerIpAndPort(StatementProxy statement, Span span) { try { URI url = URI.create(statement.getConnection().getMetaData().getURL().substring(5)); if (getZipkinServiceName() == null || &quot;&quot;.equals(getZipkinServiceName())) { try { zipkinServiceName = &quot;DB&quot;+url.getPath(); }catch (Exception e){ ; } } span.remoteServiceName(getZipkinServiceName()); String host = url.getHost(); if (host != null) { span.remoteIpAndPort(host, url.getPort()); } } catch (Exception e) { // remote address is optional } } public String getZipkinServiceName() { return zipkinServiceName; } public void setZipkinServiceName(String zipkinServiceName) { this.zipkinServiceName = zipkinServiceName; }} 总结：简单来说就是利用 Druid 提供的过滤器机制，在 SQL 语句执行前后添加追踪日志。","link":"/2019/03/18/zipkin/"}],"tags":[],"categories":[]}